\documentclass{article}
\usepackage{graphicx}
\usepackage{float}

\graphicspath{ {images/} }

\newcommand{\projectnaam}{Software Reengineering}
\newcommand{\student}{Van Muylder Ben \& Geeraert Lander}
\title{\textmd{\textbf{Final Project Report}}\\\normalsize\vspace{0.1in}\Large{\projectnaam}}
\author{\student}\date{\today}

\setcounter{section}{-1}

\begin{document}
\maketitle
\newpage

\section{Introduction}

\subsection{Context}

This project is part of the course 'Software Reengineering' at the University of Antwerp. It serves (to quote the assignment) "to demonstrate that you indeed acquired the range of principles, techniques, and skills that are currently being used for reengineering", and such we will need to (and we'll again quote the assignment) "restructure an existing software system to prepare for a given suite of new requirements".

\subsection{Do reengineer, do not implement}

As you can read in the above part, we are required to prepare the software system 'for a given suite of new requirements', hence we are not required to implement these features, as is confirmed by yet another excerpt from the assignment: 'the extra functionality as such needs not be implemented; but [...] the existing design must be adjusted in such a way that adding the new functionality becomes a [...] piece of cake".\\

We want emphasize that we will \textbf{not} be implementing the features as they were noted in the assignment (those being: having the functionality to have separate shapes for data points, and having the functionality to read shapes for data point from a database).

\subsection{Problem at hand} 

The problem which we should try to grasp is the following: a hypothetical customer wants us to refactor the existing software library 'JFreeChart'. To be more precise, he wants us to refactor the library as to allow for functionality which the library currently does not have. This functionality (as mentioned before) is a) to allow for separate shapes for data points and b) to allow for the loading of shapes from a database.

\section{Preparation}

\subsection{Scope}

The assignment is directed at a very specific part of the library. While there is no functionality to explicitly give each separate datapoint a specific shape, there is already functionlity for datapoints to have shapes (which was to be expted). While there are very much aspects to this library, many of which could perhaps require their own refactoring, we will only focus on the functionality concerning shapes. Throughout the report we might refer back to this limit as our scope.

\section{Design Recovery}

To understand what should be changed in the project, we must first understand how the project works. Since our scope is the functionality of shapes, we must thus try to work out what the role of these shapes is, and how precisely they work.

\subsection{Analysis of the current design}

We'll be honest and upfront in saying that we won't have a whole explanation of how this library works, but rather a simplified view of happens in general, concerning to our scope (with possible deeper insights in those aspects which need more explanation).\\

A shape can be used for many things, but with respect to the assignment; it's used to represent a datapoint on a plot. A datapoint can be a point of its own, or it can be part of a set of datapoints (which we mostly refer to as a serie). This serie might represent a lot of things such as just simply random points, points of data which have been imported, points which represent a (mathematical) function... 

However, purely in data, a shape does not have not much meaning. The shape itself is meant so we, the user of the library, can see these points on a screen. And when does this happen? When we export our plot (and data) to an image (for example).\\

This is where our overview of the workings begin. When we want to export to an image, we'll want to output some data to a buffer. The output comes from a draw function which is a central part of the core functionality, which in itself calls the draw functionality of the Plot interface (which is implemented by XYPlot and CategoryPlot among others...). These draw funtions do a lot of things, but one thing in particular: they render data items, or at least, set this process into motion. XYPlot for example has its own render function, which then in itself calls to the drawItem function of the renderer for that class instance (which would be an XYItemRenderer, which is in itself an interface, but is implemented in a lot of derived classes such as XYLineAndShapeRenderer). The drawItem functionality of XYLineAndShapeRender works with different passes: a first pass which draws the background, and a second pass which draws effective data items.\\

We have now reached the point where we will effectively have interaction with shapes. For simplicity we'll say that the draw function of these classes effectively \textit{draws} the shapes somewhere. But to do this, the function needs a shape to draw. They do this by calling the getItemShape function of AbstractXYItemRenderer or AbstractCategoryItemRenderer (which both inherit this function from AbstractRenderer, and which both are extended by lots of other classes, such as XYLineAndShapeRenderer). This function provides and effective shape which the draw function then can use to \textit{draw}.

getItemShape is special in 2 ways. The first way is in that it will always return the same shape for data items of the same serie (because of the deeper implementation of this function). The second way is that it is called in many other classes (which are thus extensions of AbstractXYItemRenderer and AbstractCategoryItemRenderer); unlike the function setSeriesShape (and setItemShape, which is a function which doesn't exist (yet)).\\

The function to set a specific shape for a serie (also part of AbstractRenderer), is never used in the whole project. But plots still need shapes for their data points? This is where default shapes come in play. Classes can set a shape by either changing the value for the default shape in the constructor, or by setting a shape for the series legend and then later on requesting the shape of the data point via the shape of the legend of that serie. 

\section{Design}

\subsection{The initial idea}

When figuring out how the current implementation of the library works, we noticed one thing in particular. While the library does not have the functionality which is requested by our metaphorical customer, it still possible without the need for grand refactors and restructurings of the project.\\

For example: in the above part we spoke specifically of the function getItemShape, and not of the function getSeriesShape. This is because getItemShape is meant to return a specific shape for each separate datapoint, while getSeriesShape is meant to return a shape for each separate serie. In practice, the second parameter of getItemShape (which would denote the specific point of a serie for which we want to get a shape) is completely ignored, after which getSeriesShape is called.\\

getItemShape in this case serves purely as a passthrough function, where it is explicitly mentioned in the documentation for the function that if other behaviour is required, the users should override the existing function. This however, doesn't seem to happen anywhere in the project and thus we can safely say that getItemShape effectively is the same as lookupSerieShape (which in itself calls getSeriesShape).\\

Because of this, in our opinion, the project does not refactoring to allow for the requested features, not even to make the implemenation easier, as implementing it would only require the getItemShape function to be overridden correctly. One could even write an implementation for getItemShape where they perform a specific database query (based on the row and column parameter of getItemShape) to request a specific shape from a database.\\

Nevertheless, we'll try and find more opportunities to restructure the project to allow for more ease of use.

\subsection{Pulling away the shape functionality}

While we think that the shape functionality itself does not need changing to allow for the requested features, we do think that it is not easy for people who are not familiar with the project to effectively find where the functionality of the shapes resides (which is in the AbstractRenderer class).\\

Because of this we propose to pull away this functionality from the AbstractRenderer class, and put it inside of it's own class (which we will call ShapeManager) and make AbstractRenderer extend from it, simply to provide more clarity and to make the functionality easier to find. As such, the following are diagrams of how the current implementation of AbstractXYItemRenderer is and how the current implementation of AbstractCategoryItemRenderer is.

\begin{figure}[H]
\centering
	\includegraphics[width=0.9\textwidth]{AbstractXYItemRendererBefore.png}
	\caption{AbstractXYItemRenderer before any refactorings}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[width=0.9\textwidth]{AbstractCategoryItemRendererBefore.png}
	\caption{AbstractCategoryItemRenderer before any refactorings}
\end{figure}

What is important to note from these figures, is that AbstractRenderer (the class where the shape functionality resides) has not further dependencies. This is what will change in our proposed design.
As such, the following are diagrams of how our proposed implementation is for AbstractXYItemRenderer and AbstractCategoryRenderer.

\begin{figure}[H]
\centering
	\includegraphics[width=0.9\textwidth]{AbstractXYItemRendererAfter.png}
	\caption{AbstractXYItemRenderer after refactoring}
\end{figure}

\begin{figure}[H]
\centering
	\includegraphics[width=0.9\textwidth]{AbstractCategoryItemRendererAfter.png}
	\caption{AbstractCategoryItemRenderer after refactoring}
\end{figure}

To reiterate; we want to perform this refactor purely for the sake of clarity, to help our (hypothetical) customer with figuring out where he should start with the implementation of his new functionality.

\subsection{Risks}

Since we simply want to pull away the functionality, and put it in a class from which the original class will extend, we effectively make sure that our original class doesn't change (since a compiled version will use flattened versions for classes, having the original class extend from the class with the functionality, makes it so that our original class (which is AbstractRenderer) keeps the functionality which we pulled away).\\

As such it fairly clear that there aren't much risks involved with performing this refactor. Nevertheless, we should at least a) check with an IDE whether we have created errors and b) rerun the existing test suite. If the test suite fails, there is a problem. However, if it succeeds this can mean either that everything still works, or that the existing test suite is not capable and produced a false positive. Nevertheless, we'll assume that we started with a stable version of the library, which has a capable test suite.


\section{Management}

\section{Refactoring}



\subsection[Section Title. Section Subtitle]{Refactoring Stage 2\\ {\large Understanding the shape functionality}}


\newpage
\section{Conclusion}


\end{document}